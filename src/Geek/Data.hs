{-# LANGUAGE OverloadedLists, OverloadedStrings #-}

module Geek.Data where

import Data.Char(isAlphaNum)
import Data.Default(def)
import Data.Map.Strict(Map)
import qualified Data.Map.Strict as M
import Data.Set(empty, fromList)
import Data.Text(Text, isSuffixOf, pack)
import qualified Data.Text as T
import Data.Text.Lazy(fromStrict)
import qualified Data.Text.Lazy as L
import Data.Time.Calendar(Day, toGregorian)
import Data.Time.Clock(UTCTime(UTCTime))

import Network.URI(URI, parseURI)

import Text.ICalendar.Types(
    Categories(Categories), Comment(Comment), Created(Created), Date, DateTime, DTStamp(DTStamp), EventStatus(ConfirmedEvent), FBType(Free), Frequency(Yearly)
  , Language(Language), LastModified(LastModified), RRule(RRule), Recur(Recur), Summary(Summary), TimeTransparency(Transparent), UID(UID), URL(URL)
  , VCalendar(vcEvents)
  , VEvent(
      VEvent, veAlarms, veAttach, veAttendee, veCategories, veClass, veComment, veContact, veCreated, veDescription, veDTEndDuration, veDTStamp
    , veDTStart, veExDate, veGeo, veLastMod, veLocation, veOrganizer, veOther, vePriority, veRDate, veRecurId, veRelated, veResources, veRRule
    , veRStatus, veSeq, veSummary, veStatus, veTransp, veUID, veUrl
    )
  , Weekday(Monday)
  )

_fbType :: FBType
_fbType = Free

_language :: Maybe Language
_language = Just (Language "EN")

_projectLink :: Maybe URI
_projectLink = parseURI "https://github.com/hapytex/geek-calendar"

_eventComment :: Comment
_eventComment = Comment "Generated by geek-calendar" _projectLink _language def

toPossessive :: Text -> Text
toPossessive t
    | isSuffixOf "s" t = t <> "'"
    | otherwise = t <> "'s"

newtype FixedDay = FixedDay Day deriving (Eq, Ord, Show)

data Event
  = Birthday { person :: Text, birthDay :: FixedDay, deathday :: Maybe Day }  -- birthday is the event
  deriving (Eq, Ord, Show)

data GeekEvent
  = GeekEvent { event :: Event, julian :: Bool, links :: [URI], notes :: Text }
  deriving (Eq, Ord, Show)

class ToRecur a where
    toRecur :: a -> Recur
    toRRule :: a -> RRule
    toRRule = (`RRule` def) . toRecur
    startTime' :: a -> UTCTime
    startTime :: a -> DTStamp
    startTime = (`DTStamp` def) . startTime'

class ToCategories a where
    toCategories :: a -> [Text]

class ToUniqueIdentifier a where
    toUniqueIdentifier' :: a -> Text
    toUniqueIdentifier :: a -> UID
    toUniqueIdentifier = (`UID` def) . fromStrict . toUniqueIdentifier'

class ToSummary a where
    toSummary' :: a -> Text
    toSummary :: a -> Summary
    toSummary x = Summary (fromStrict (toSummary' x)) Nothing _language def

instance ToRecur FixedDay where
    toRecur (FixedDay d) = Recur Yearly Nothing 1 [] [] [] [] [] [] [] [] [] Monday
    startTime' (FixedDay d) = UTCTime d 0

instance ToRecur Event where
    toRecur Birthday { birthDay=bd } = toRecur bd
    startTime' Birthday { birthDay=bd } = startTime' bd

instance ToRecur GeekEvent where
    toRecur GeekEvent {event=ev} = toRecur ev
    startTime' GeekEvent {event=ev} = startTime' ev

instance ToCategories Event where
    toCategories Birthday { person=p } = [p, "birthday"]

instance ToCategories GeekEvent where
    toCategories GeekEvent { event=e } = toCategories e

instance ToSummary Event where
    toSummary' Birthday { person=p } = toPossessive p <> " Birthday"

instance ToSummary GeekEvent where
    toSummary' GeekEvent { event=e } = toSummary' e
    toSummary GeekEvent { event=e } = toSummary e

instance ToUniqueIdentifier Day where
    toUniqueIdentifier' dy = pack (show (10000 * y + 100 * fromIntegral m + fromIntegral d))
        where (y, m, d) = toGregorian dy

instance ToUniqueIdentifier FixedDay where
    toUniqueIdentifier' (FixedDay d) = toUniqueIdentifier' d

instance ToUniqueIdentifier Text where
    toUniqueIdentifier' = T.map f
        where f c | isAlphaNum c = c
                  | otherwise = '-'

instance ToUniqueIdentifier Event where
    toUniqueIdentifier' Birthday { person=p, birthDay=bd } = toUniqueIdentifier' bd <> "-" <> toUniqueIdentifier' p

instance ToUniqueIdentifier GeekEvent where
    toUniqueIdentifier GeekEvent {event=e} = toUniqueIdentifier e
    toUniqueIdentifier' GeekEvent {event=e} = toUniqueIdentifier' e

urisToUrl :: [URI] -> Maybe URL
urisToUrl (x:_) = Just (URL x def)
urisToUrl _ = Nothing

_geekCategories :: [Text] -> Categories
_geekCategories ts = Categories (fromList ("geek" : map fromStrict ts)) _language def

toEvent :: UTCTime -> GeekEvent -> ((L.Text, Maybe (Either Date DateTime)), VEvent)
toEvent utc (g@GeekEvent { links=l }) = ((fromStrict (toUniqueIdentifier' g), Nothing), VEvent {
    veAlarms=empty
  , veAttach=empty
  , veAttendee=empty
  , veCategories=[_geekCategories (toCategories g)]
  , veClass=def
  , veComment=[_eventComment]
  , veContact=empty
  , veCreated=Just (Created utc def)
  , veDTEndDuration=Nothing
  , veDTStart=Nothing
  , veDTStamp=startTime g
  , veDescription=Nothing  -- TODO: add description!
  , veExDate=empty
  , veGeo=Nothing  -- TODO: can be spec'ed
  , veLastMod=Just (LastModified utc def)
  , veLocation=Nothing  -- TODO: can be spec'ed
  , veOrganizer=Nothing  -- TODO: can be spec'ed
  , veOther=empty
  , vePriority=def
  , veRDate=empty
  , veRecurId=Nothing
  , veRelated=empty  -- TODO: can be spec'ed
  , veResources=empty
  , veRRule=[toRRule g]
  , veRStatus=empty
  , veSeq=def
  , veStatus=Just (ConfirmedEvent def)
  , veSummary=Just (toSummary g)
  , veTransp=Transparent def
  , veUID=toUniqueIdentifier g
  , veUrl=urisToUrl l
  })

packCalendar :: UTCTime -> [GeekEvent] -> VCalendar
packCalendar utc gs = def {
    vcEvents=M.fromList (map (toEvent utc) gs)
  }
